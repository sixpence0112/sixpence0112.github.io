{"pages":[{"title":"","text":"12# sixpence0112.github.iosixpence0112的博客","link":"/README.html"},{"title":"'intellij'","text":"","link":"/intellij/index.html"}],"posts":[{"title":"Docker;","text":"Ubuntu16.04配置阿里云数据源 1234567891011121314151617181920212223cd /etc/aptvi sourcee.listdeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverseapt-get update Docker安装：apt-get install -y apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -add-apt-repository “deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable”apt-get update docker-compose安装 curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-uname -s-uname -m -o /usr/local/bin/docker-compose 12curl -L https://get.daocloud.io/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose 1chmod +x /usr/local/bin/docker-compose","link":"/2020/08/05/Docker/"},{"title":"Docker学习--Nexus服务搭建","text":"docker hub 上找到 sonatype/nexus 镜像 1docker pull sonatype/nexus:版本号 编写nexus-compose.yml文件 12345678910version: &apos;2&apos;services: nexus: image: sonatype/nexus:2.14.5 restart: always container_name: nexus ports: - &apos;8081:8081&apos; volumes: - /usr/local/docker/nexus/data:/nexus-data 启动 1docker-compose up -d 配置认证信息 在Maven setting.xml中添加Nexus认证信息（servers 节点下） 1234567891011&lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 配置自动化部署 在pom.xml中添加 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;user-release&lt;/id&gt; &lt;name&gt;user release resp&lt;/name&gt; &lt;url&gt;http://192.168.44.128:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;name&gt;user snapshots resp&lt;/name&gt; &lt;url&gt;http://192.168.44.128:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 配置代理仓库 在pom.xml中添加 1234567891011121314151617181920212223242526&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Repository&lt;/name&gt; &lt;url&gt;http://192.168.172.141:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Plugin Repository&lt;/name&gt; &lt;url&gt;http://192.168.172.141:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;","link":"/2019/09/28/Docker学习-Nexus服务搭建/"},{"title":"Linux学习杂记","text":"配置Java环境变量 配置系统环境变量 vi /etc/enviroment 打开系统配置文件 添加如下配置 123export JAVA_HOME=/usr/local/java/jdk1.8.0_211export JRE_HOME=/usr/local/java/jdk1.8.0_211/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib 配置用户环境变量 vi /etc/profile 打开系统配置文件 添加如下配置,在图片所示位置 123export JAVA_HOME=/usr/local/java/jdk1.8.0_211export JRE_HOME=/usr/local/java/jdk1.8.0_211/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib ​ tomcat安装 下载jdk对应版本tomcat：https://tomcat.apache.org/download-80.cgi 将文件放入相应目录，执行 1tar -xzvf apache-tomcat-8.5.45.tar.gz 将解压后的文件转移至目标文件夹 1mv apache-tomcat-8.5.45 /usr/local mysql安装 1.下载并安装MySQL官方的 Yum Repository 1`wget -i -c http:``//dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm` 如果 wegt 未安装的话可以先用 yum 安装 wget ： 1`yum install wget` 安装mysql57-community-release-el7-10.noarch.rpm包 1`yum -y install mysql57-community-release-el7-10.noarch.rpm` 安装这个包后，会获得两个mysql的yum repo源：/etc/yum.repos.d/mysql-community.repo，/etc/yum.repos.d/mysql-community-source.repo。 安装MySQL 1`yum -y install mysql-community-server` 至此MySQL就安装完成了，然后是对MySQL的一些设置。 修改密码 首先启动MySQL： 1`systemctl start mysqld.service` 查看mysql运行状态： 1`systemctl status mysqld.service` 找出在日志文件中的密码： 1`grep ``&quot;password&quot;` `/``var``/log/mysqld.log` 进入数据库 1`mysql -uroot -p` 输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库： 1`mysql&gt; ALTER USER ``&apos;root&apos;``@``&apos;localhost&apos;` `IDENTIFIED BY ``&apos;new password&apos;``;` ​ 修改密码设置策略 1set global validate_password_policy=0;","link":"/2019/08/22/Linux学习杂记/"},{"title":"@Scheduled参数详解","text":"参数详解1. cron该参数接收一个cron表达式，cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义。 cron表达式语法1[秒] [分] [小时] [日] [月] [周] [年] 注：[年]不是必须的域，可以省略[年]，则一共6个域 序号 说明 必填 允许填写的值 允许的通配符 1 秒 是 0-59 , - * / 2 分 是 0-59 , - * / 3 时 是 0-23 , - * / 4 日 是 1-31 , - * ? / L W 5 月 是 1-12 / JAN-DEC , - * / 6 周 是 1-7 or SUN-SAT , - * ? / L # 7 年 否 1970-2099 , - * / 通配符说明: * 表示所有值。 例如:在分的字段上设置 *,表示每一分钟都会触发。 ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ? - 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。 , 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发 / 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。 L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五” W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)。 # 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：’L’和 ‘W’可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON与mon相同。 示例每隔5秒执行一次：/5 * ? 每隔1分钟执行一次：0 /1 ? 每天23点执行一次：0 0 23 ? 每天凌晨1点执行一次：0 0 1 ? 每月1号凌晨1点执行一次：0 0 1 1 * ? 每月最后一天23点执行一次：0 0 23 L * ? 每周星期天凌晨1点实行一次：0 0 1 ? * L 在26分、29分、33分执行一次：0 26,29,33 * ? 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 ? cron表达式使用占位符另外，cron属性接收的cron表达式支持占位符。eg： 配置文件： 123time: cron: */5 * * * * * interval: 5 每5秒执行一次： 123456789@Scheduled(cron=\"${time.cron}\")void testPlaceholder1() { System.out.println(\"Execute at \" + System.currentTimeMillis());}@Scheduled(cron=\"*/${time.interval} * * * * *\")void testPlaceholder2() { System.out.println(\"Execute at \" + System.currentTimeMillis());} 2. zone时区，接收一个java.util.TimeZone#ID。cron表达式会基于该时区解析。默认是一个空字符串，即取服务器所在地的时区。比如我们一般使用的时区Asia/Shanghai。该字段我们一般留空。 3. fixedDelay上一次执行完毕时间点之后多长时间再执行。如： 1@Scheduled(fixedDelay = 5000) //上一次执行完毕时间点之后5秒再执行 4. fixedDelayString与 3. fixedDelay 意思相同，只是使用字符串的形式。唯一不同的是支持占位符。如： 1@Scheduled(fixedDelayString = \"5000\") //上一次执行完毕时间点之后5秒再执行 占位符的使用(配置文件中有配置：time.fixedDelay=5000)： 1234@Scheduled(fixedDelayString = \"${time.fixedDelay}\")void testFixedDelayString() { System.out.println(\"Execute at \" + System.currentTimeMillis());} 运行结果： 占位符的使用 5. fixedRate上一次开始执行时间点之后多长时间再执行。如： 1@Scheduled(fixedRate = 5000) //上一次开始执行时间点之后5秒再执行 6. fixedRateString与 5. fixedRate 意思相同，只是使用字符串的形式。唯一不同的是支持占位符。 7. initialDelay第一次延迟多长时间后再执行。如： 1@Scheduled(initialDelay=1000, fixedRate=5000) //第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次 8. initialDelayString与 7. initialDelay 意思相同，只是使用字符串的形式。唯一不同的是支持占位符。","link":"/2019/09/11/Scheduled参数详解/"},{"title":"","text":"12# sixpence0112.github.iosixpence0112的博客","link":"/2019/10/12/README/"},{"title":"daily","text":"最近在看Woody·Allen导演的电影和菲利普·迪克原创小说改编的电影","link":"/2020/03/21/daily/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/12/hello-world/"},{"title":"'intellij快捷键'","text":"1.ctrl+alt+v：自动补全返回值 2.ctrl+alt+T：try…catch if…else补全","link":"/2019/05/18/intellij/"},{"title":"'jsp页面获取session值'","text":"​ jsp页面获取session值java代码 12345678910@RequestMapping(value = &quot;/chkUser&quot;,method = RequestMethod.POST,produces = &quot;application/json;charset=UTF-8&quot;) public String chkUserInfo(HttpServletRequest request,String userName, String userPwd){ if(StringUtils.isBlank(userName)||StringUtils.isBlank(userPwd)) return &quot;false&quot;; UserEntity entity = chkLoginService.chkUserService(userName,userPwd); if(entity==null) return &quot;false&quot;; request.getSession().setAttribute(&quot;userEntity&quot;,entity); return &quot;true&quot;; } 方法一jsp页面使用 request.getSession().getAttribute(“**“) 方法 方法二在jsp页面 script中使用EL表达式获取var userEntity=’${sessionScope.userEntity.loginName}’;说明1、sessionScope指的是session的范围，类似还有requestScope，pageScope,contextScope 2、sessionScope整体的意思是获得存放在session.setAttrbute(key,value)的值即session.getAttribute(key) 原文：https://blog.csdn.net/xiongdaandxiaomi/article/details/80593244","link":"/2019/06/18/jsp页面获取session值/"},{"title":"linux修改只读文件","text":"Linux 修改只读文件进入文件所在位置 — 例如：cd /etc （在etc文件夹下有文件hosts）查看文件 — 命令：vim host 然后enter编辑该文件 — 点击insert，就可以编辑了，上下箭头移动到要编辑的位置保存文件 — 按下Esc，之后，键入命令：:w !sudo tee %，输入密码然后，警告文件已被修改了，并显示出一个选项菜单。这里按 L键重新将该文件载入缓冲区。Press ENTER or type command to continueW12: Warning: File “/etc/profile” has changed and the buffer was changed in Vim as wellSee “:help W12” for more info. [O]K, (L)oad File:","link":"/2019/05/06/linux修改只读文件/"},{"title":"js监听input框","text":"onpropertychange： IE下，当一个HTML元素的属性改变的时候，都能通过 onpropertychange来即时捕获。onchange在属性值改变时还必须使得当前元素失去焦点(onblur)才可以激活该事件。 在用js脚本改动该元素值时候亦能触发onpropertychange事件。oninput：是onpropertychange的非IE浏览器版本，支持firefox和opera等浏览器，但有一点不同，它绑定于对象时，并非该对象所有属性改变都能触发事件，它只在对象value值发生改变时奏效。 onchange： (a)当前对象属性改变，并且是由键盘或鼠标事件激发的（脚本触发无效）；(b)当前对象失去焦点(onblur) ； jQuery用法$(&quot;#input1&quot;).bind(&quot;input propertychange&quot;,function(event){ console.log($(&quot;#input1&quot;).val()) }); 原生Js用法123456789101112131415 &lt;script type=&quot;text/javascript&quot;&gt; // Firefox, Google Chrome, Opera, Safari, Internet Explorer from version 9 function OnInput (event) { alert (&quot;The new content: &quot; + event.target.value); } // Internet Explorer function OnPropChanged (event) { if (event.propertyName.toLowerCase () == &quot;value&quot;) { alert (&quot;The new content: &quot; + event.srcElement.value); } } &lt;/script&gt; //Input标签&lt;input type=&quot;text&quot; oninput=&quot;OnInput (event)&quot; onpropertychange=&quot;OnPropChanged (event)&quot; value=&quot;Text field&quot; /&gt;","link":"/2019/06/03/js监听input框/"},{"title":"'linux命令''","text":"sudo chmod -R 777 /工作目录 获取工作目录下的文件操作权限（解决permission denied问题） ps -ef |grep tomcat 产看进程，grep后边可跟应用名或者端口号 tail -f logs/catalina.out 查看tomcat日志，须在tomcat目录下执行 cp -r userfiles /home 复制文件userfiles到/home目录下 netstat -anp |grep 端口号 查看端口占用 netstat -nultp 查看当前所有已经使用的端口情况 firewall-cmd –state 查看防火墙运行状态 start firewalld.service 启动防火墙 firewall-cmd –permanent –zone=public –add-port=8080-8081/tcp 开放某个端口 firewall-cmd –permanent –zone=public –add-service=https 开启服务 firewall-cmd –permanent –zone=public –list-services //服务空格隔开 查看开启的服务 firewall-cmd –permanent –zone=public –list-ports //端口空格隔开 查看开启的端口 iptables -L -n | grep 21 检查设定是否生效 ps -ef|grep tomcat 查看程序启动情况","link":"/2019/05/20/linux命令/"},{"title":"postName","text":"12","link":"/2013/12/02/my-first-blog/"},{"title":"tomcat配置IP访问;","text":"1、修改背景：A、通常我们访问我们的web应用格式为： 1http://ip:端口号/项目名称 例如： 1http://127.0.0.1:8080/projectName B、如果想直接输入“本地ip”直接进入应用，该如何设置呢？如下面URL： 1http://127.0.0.1 2、修改tomcat默认端口号、默认项目（应用）名称：A、先将tomcat的默认端口“8080”改为缺省的端口号“80：需要修改”tomcat”根目录下的”conf”目录下的”server.xml”文件” 1&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 把上面标签中”port”属性”8080”修改为”80”即可（访问url可以不输入端口号）。 备注：tomcat默认端口号为8080，http服务的默认端口号为80。在浏览器地址栏输入ip或者域名之后，如果不输入端口号，默认就是80端口。 2、设置默认应用(这里用到一个小技巧，注释掉的默认应用配置，默认输入ip就去访问Tomcat主页) A：注释如下： 备注：如果不配置标签,由于没有docBase指明项目位置，则项目必须放在host配置中对应的appBase地址下（如webapps）,Tomcat启动时会加载webapps下所有项目，且没有path指引时，默认指引是项目名称。就会访问Tomcat ROOT下的web.xml index.jsp 主页(index.jsp)(因为Tomacat主页是ROOT文件夹下的)。 B：修改ROOT下的index.jsp文件 &lt;%response.sendRedirect(“/myProject/index.html”);//myProject这里就是我们不熟的项目名称了。%&gt;","link":"/2019/07/27/tomcat配置IP访问/"},{"title":"一些注解的说明","text":"@EnableConfigurationProperties 使使用 @ConfigurationProperties 注解的类生效。 如果一个配置类只配置@ConfigurationProperties注解，而没有使用@Component，那么在IOC容器中是获取不到properties 配置文件转化的bean。说白了 @EnableConfigurationProperties 相当于把使用 @ConfigurationProperties 的类进行了一次注入。 @ConfigurationProperties 将配置文件application.properties中配置的每一个属性值映射到当前类的属性中； @ConfigurationProperties：告诉springboot将本类中所有属性和配置文件中相关的配置进行绑定；prefix=”person”：指出将配置文件中person下的所有属性进行一一映射； @Value @Value(“${person.last-name}”) 从配置文件中获取值 @EnableWebSecurity @EnableWebSecurity是Spring Security用于启动 Web安全的注解。 典型的用法是该注解用在某个Web安全配置类上(实现了接口WebSecurityConfigurer或者继承自WebSecurityConfigurerAdapter)。","link":"/2019/09/10/一些注解的说明/"},{"title":"'开启/关闭Ubuntu防火墙'","text":"安装方法1sudo apt-get install ufw 当然，这是有图形界面的(比较简陋)，在新立得里搜索gufw试试…… 使用方法1 启用 1sudo ufw enable 1sudo ufw default deny 作用：开启了防火墙并随系统启动同时关闭所有外部对本机的访问（本机访问外部正常）。 2 关闭 1sudo ufw disable 2 查看防火墙状态 1sudo ufw status 3 开启/禁用相应端口或服务举例 1sudo ufw allow 80 允许外部访问80端口 1sudo ufw delete allow 80 禁止外部访问80 端口 1sudo ufw allow from 192.168.1.1 允许此IP访问所有的本机端口 1sudo ufw deny smtp 禁止外部访问smtp服务 1sudo ufw delete allow smtp 删除上面建立的某条规则 1sudo ufw deny proto tcp from 10.0.0.0/8 to 192.168.0.1 port 22 要拒绝所有的TCP流量从10.0.0.0/8 到192.168.0.1地址的22端口 1234 可以允许所有RFC1918网络（局域网/无线局域网的）访问这个主机（/8,/16,/12是一种网络分级）：sudo ufw allow from 10.0.0.0/8sudo ufw allow from 172.16.0.0/12sudo ufw allow from 192.168.0.0/16 推荐设置1sudo apt-get install ufw 1sudo ufw enable 1sudo ufw default deny 这样设置已经很安全，如果有特殊需要，可以使用sudo ufw allow开启相应服务。","link":"/2019/05/08/开启-关闭Ubuntu防火墙/"},{"title":"自定义注解注","text":"1.注解的官方定义 ​ 注解是一种元数据形式。即注解是属于java的一种数据类型，和类、接口、数组、枚举类似。 ​ 注解来修饰，类、方法、变量、参数、包。 ​ 注解不会对所修饰的代码产生直接的影响。 2.如何定义注解 第一步，定义注解——相当于定义标记； 第二步，配置注解——把标记打在需要用到的程序代码中； 第三步，解析注解——在编译期或运行时检测到标记，并进行特殊操作。","link":"/2020/08/24/自定义注解注/"},{"title":"待学习","text":"函数式接口 lambda公式","link":"/2019/08/30/待学习/"},{"title":"Mybatis-Plus学习","text":"这是一片关于Mybatis-Plus的学习笔记，记录学习的过程与感悟。仅适用于自身。 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt;&lt;/dependency&gt; 123 WARNING引入 `MyBatis-Plus` 之后请不要再次引入 `MyBatis` 以及 `MyBatis-Spring`，以避免因版本差异导致的问题 2.在application.yml文件中添加配置 123456789#mybatis plus 设置mybatis-plus: type-aliases-package: cc.mrbird.febs.system.domain,cc.mrbird.febs.job.domain mapper-locations: classpath:mapper/*/*.xml configuration: jdbc-type-for-null: null global-config: # 关闭 mybatis-plus的 banner banner: false typeAliasesPackage​ MyBaits 别名包扫描路径，通过该属性可以给包中的类注册别名，注册后在 Mapper 对应的 XML 文件中可以直接使用类名，而不用使用全限定的类名（即 XML 中调用的时候不用包含包名）。 ​ 例如： 1&lt;select id=&quot;queryList&quot; resultType=&quot;job&quot;&gt;&lt;/select&gt; typeAliasesSuperType​ 该配置请和 typeAliasesPackage 一起使用，如果配置了该属性，则仅仅会扫描路径下以该类作为父类的域对象 。 功能 代码生成 参照官方文档进行配置，基本不会出幺蛾子。模板选项有freemarker，String templatePath = &quot;/templates/mapper.xml.ftl&quot; 和velocity， String templatePath = &quot;/templates/mapper.xml.vm&quot; 也可自定义模板。代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 数据库 URLprivate static final String URL = &quot;jdbc:mysql://127.0.0.1:3306/sixpence?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&quot;;// 数据库驱动private static final String DRIVER_NAME = &quot;com.mysql.jdbc.Driver&quot;;// 数据库用户名private static final String USERNAME = &quot;root&quot;;// 数据库密码private static final String PASSWORD = &quot;root&quot;;// @author 值private static final String AUTHOR = &quot;sixpence&quot;;// 包的基础路径private static final String BASE_PACKAGE_URL = &quot;com.sixpence.mp&quot;;// xml文件路径private static final String XML_PACKAGE_URL = &quot;/src/main/resources/mapper/&quot;;// xml 文件模板private static final String XML_MAPPER_TEMPLATE_PATH = &quot;generator/templates/mapper.xml&quot;;// mapper 文件模板private static final String MAPPER_TEMPLATE_PATH = &quot;generator/templates/mapper.java&quot;;// entity 文件模板private static final String ENTITY_TEMPLATE_PATH = &quot;generator/templates/entity.java&quot;;// service 文件模板private static final String SERVICE_TEMPLATE_PATH = &quot;generator/templates/service.java&quot;;// serviceImpl 文件模板private static final String SERVICE_IMPL_TEMPLATE_PATH = &quot;generator/templates/serviceImpl.java&quot;;// controller 文件模板private static final String CONTROLLER_TEMPLATE_PATH = &quot;generator/templates/controller.java&quot;;public static void main(String[] args) { // 代码生成器 AutoGenerator generator = new AutoGenerator(); // 全局配置 GlobalConfig globalConfig = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); globalConfig.setOutputDir(projectPath + &quot;/src/main/java&quot;); globalConfig.setAuthor(AUTHOR); globalConfig.setOpen(false); globalConfig.setFileOverride(false); generator.setGlobalConfig(globalConfig); // 数据源配置 DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setUrl(URL); // dataSourceConfig.setSchemaName(&quot;public&quot;); dataSourceConfig.setDriverName(DRIVER_NAME); dataSourceConfig.setUsername(USERNAME); dataSourceConfig.setPassword(PASSWORD); generator.setDataSource(dataSourceConfig); // 包配置 PackageConfig packageConfig = new PackageConfig(); packageConfig.setModuleName(&quot;gen&quot;); packageConfig.setParent(BASE_PACKAGE_URL); generator.setPackageInfo(packageConfig); // 配置自定义代码模板 TemplateConfig templateConfig = new TemplateConfig(); templateConfig.setXml(XML_MAPPER_TEMPLATE_PATH); templateConfig.setMapper(MAPPER_TEMPLATE_PATH); templateConfig.setEntity(ENTITY_TEMPLATE_PATH); templateConfig.setService(SERVICE_TEMPLATE_PATH); templateConfig.setServiceImpl(SERVICE_IMPL_TEMPLATE_PATH); templateConfig.setController(CONTROLLER_TEMPLATE_PATH); generator.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); //strategy.setSuperEntityClass(&quot;com.baomidou.ant.common.BaseEntity&quot;); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); //strategy.setSuperControllerClass(&quot;com.baomidou.ant.common.BaseController&quot;); strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;)); strategy.setSuperEntityColumns(&quot;id&quot;); strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(packageConfig.getModuleName() + &quot;_&quot;); generator.setStrategy(strategy); generator.setTemplateEngine(new FreemarkerTemplateEngine()); generator.execute();}private static String scanner(String tip) { Scanner scanner = new Scanner(System.in); System.out.println((&quot;请输入&quot; + tip + &quot;：&quot;)); if (scanner.hasNext()) { String ipt = scanner.next(); if (StringUtils.isNotBlank(ipt)) return ipt; } throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;);} CRUD接口 Mapper的CRUD接口 说明: 通用 CRUD 封装BaseMapper接口，为 Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器 泛型 T 为任意实体对象 参数 Serializable 为任意类型主键 Mybatis-Plus 不推荐使用复合主键约定每一张表都有自己的唯一 id 主键 对象 Wrapper 为 条件构造器 以下为部分接口方法： insert 123456789/** * &lt;p&gt; * 插入一条记录 * &lt;/p&gt; * * @param entity 实体对象 * @return 插入成功记录数 */int insert(T entity); - delete 123456789/** * &lt;p&gt; * 根据 entity 条件，删除记录 * &lt;/p&gt; * * @param wrapper 实体对象封装操作类（可以为 null） * @return 删除成功记录数 */int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper); - updateById 123456789/** * &lt;p&gt; * 根据 ID 修改 * &lt;/p&gt; * * @param entity 实体对象 * @return 修改成功记录数 */int updateById(@Param(Constants.ENTITY) T entity); - selectMaps 123456789/** * &lt;p&gt; * 根据 Wrapper 条件，查询全部记录 * &lt;/p&gt; * * @param queryWrapper 实体对象封装操作类（可以为 null） * @return 字段映射对象 Map 集合 */List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); Service的CRUD接口 说明: 通用 Service CRUD 封装IService接口，进一步封装 CRUD 采用 get 查询单行 remove 删除`list 查询集合page 分页前缀命名方式区分Mapper` 层避免混淆， 泛型 T 为任意实体对象 建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类 对象 Wrapper 为 条件构造器 关于接口内容不再赘述，偶需要看文档。 条件构造器 详见文档 分页插件 1234567&lt;!-- spring xml 方式 --&gt;&lt;plugins&gt; &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;&gt; &lt;property name=&quot;sqlParser&quot; ref=&quot;自定义解析类、可以没有&quot; /&gt; &lt;property name=&quot;dialectClazz&quot; value=&quot;自定义方言类、可以没有&quot; /&gt; &lt;/plugin&gt;&lt;/plugins&gt; 1234567891011121314//Spring boot方式@EnableTransactionManagement@Configuration@MapperScan(&quot;com.baomidou.cloud.service.*.mapper*&quot;)public class MybatisPlusConfig { /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); }} 自定义分页 UserMapper.java方法内容 12345678910111213public interface UserMapper{//可以继承或者不继承BaseMapper /** * &lt;p&gt; * 查询 : 根据state状态查询用户列表，分页显示 * 注意!!: 如果入参是有多个,需要加注解指定参数名才能在xml中取值 * &lt;/p&gt; * * @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位(你可以继承Page实现自己的分页对象) * @param state 状态 * @return 分页对象 */ IPage&lt;User&gt; selectPageVo(Page page, @Param(&quot;state&quot;) Integer state);} UserMapper.xml编写一个list查询 123&lt;select id=&quot;selectPageVo&quot; resultType=&quot;com.baomidou.cloud.entity.UserVo&quot;&gt; SELECT id,name FROM user WHERE state=#{state}&lt;/select&gt; UserServiceImpl调用分页方法 1234567public IPage&lt;User&gt; selectUserPage(Page&lt;User&gt; page, Integer state) { // 不进行 count sql 优化，解决 MP 无法自动优化 SQL 问题，这时候你需要自己查询 count 部分 // page.setOptimizeCountSql(false); // 当 total 为非 0 时(默认为 0),分页插件不会进行 count 查询 // 要点!! 分页返回的对象与传入的对象是同一个 return userMapper.selectPageVo(page, state);} 代码示例如下： 123456789101112131415161718192021222324252627282930313233public class PaginationTest { @Resource private UserMapper mapper; @Test public void tests() { System.out.println(&quot;----- baseMapper 自带分页 ------&quot;); Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); IPage&lt;User&gt; userIPage = mapper.selectPage(page, new QueryWrapper&lt;User&gt;() .eq(&quot;age&quot;, 20).eq(&quot;name&quot;, &quot;Jack&quot;)); assertThat(page).isSameAs(userIPage); System.out.println(&quot;总条数 ------&gt; &quot; + userIPage.getTotal()); System.out.println(&quot;当前页数 ------&gt; &quot; + userIPage.getCurrent()); System.out.println(&quot;当前每页显示数 ------&gt; &quot; + userIPage.getSize()); print(userIPage.getRecords()); System.out.println(&quot;----- baseMapper 自带分页 ------&quot;); System.out.println(&quot;json 正反序列化 begin&quot;); String json = JSON.toJSONString(page); Page&lt;User&gt; page1 = JSON.parseObject(json, TypeBuilder.newInstance(Page.class).addTypeParam(User.class).build()); print(page1.getRecords()); System.out.println(&quot;json 正反序列化 end&quot;); System.out.println(&quot;----- 自定义 XML 分页 ------&quot;); MyPage&lt;User&gt; myPage = new MyPage&lt;User&gt;(1, 5).setSelectInt(20).setSelectStr(&quot;Jack&quot;); ParamSome paramSome = new ParamSome(20, &quot;Jack&quot;); MyPage&lt;User&gt; userMyPage = mapper.mySelectPage(myPage, paramSome); assertThat(myPage).isSameAs(userMyPage); System.out.println(&quot;总条数 ------&gt; &quot; + userMyPage.getTotal()); System.out.println(&quot;当前页数 ------&gt; &quot; + userMyPage.getCurrent()); System.out.println(&quot;当前每页显示数 ------&gt; &quot; + userMyPage.getSize()); print(userMyPage.getRecords()); System.out.println(&quot;----- 自定义 XML 分页 ------&quot;); } ### sql分析打印 ​ 该功能依赖 `p6spy` 组件，完美的输出打印 SQL 及执行时长 `3.1.0` 以上版本 - p6spy 依赖引入 12345&lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; - application.yml配置 12345spring: datasource: dynamic: # 是否开启 SQL日志输出，生产环境建议关闭，有性能损耗 p6spy: true - spy.properties配置 12345678910111213# p6spy配置，文档 https://p6spy.readthedocs.io/en/latest/configandusage.html# 使用日志系统记录 sqlappender=com.p6spy.engine.spy.appender.Slf4JLogger# 自定义日志打印logMessageFormat=cc.mrbird.febs.common.config.P6spySqlFormatConfig# 是否开启慢 SQL记录outagedetection=true# 慢 SQL记录标准 2 秒outagedetectioninterval=2# 开启过滤filter=true# 包含 QRTZ的不打印exclude=QRTZ","link":"/2019/04/26/Mybatis-Plus学习/"},{"title":"'Nginx入门学习'","text":"N滚下入门学习 下载安装 Nginx官网：http://nginx.org/en/download.html Github项目地址：https://github.com/nginx/nginx Mainline version: Mainline 是 Nginx 目前主力在做的版本，可以说是开发版 Stable version: 最新稳定版，生产环境上建议使用的版本 Legacy versions:遗留的老版本的稳定版 下载完成之后解压，目录如下， Nginx解压完毕之后，直接双击nginx.exe 即可启动，当Nginx启动之后，通过nginx -s 命令可以实现停止nginx和重新加载配置文件。 12345nginx -s stop # 立即停止nginx -s quit # 停止，在Nginx停止前会等待当前正在进行的任务nginx -s reload # 重新加载配置文件nginx –v # 查看nginx版本nginx -t # 测试当前配置文件是否正确 Nginx作为普通HttpServer简单来说，任何可以通过Http请求的方式访问IO资源（文件是对磁盘IO的一种抽象）服务都可以称为HttpServer。你可以自己写一个程序监听一个端口，当使用浏览器输入ip:port/path 访问，程序获取浏览器获取到Http请求报文，然后对URI部分（也就是path部分）进行解析，在本地文件系统或者其他IO资源中找到对应的资源，通过封装一个Http响应报文，将资源内容放入响应体中写回给浏览器，浏览器就会对其进行解析并展示（或者下载），这就完成了最简单的Http服务器。但我们平时应用的Http服务器需要处理的细节是很多的，如IO复用，安全性等，在此不再赘述。 首先复制conf/nginx.conf 为conf/nginx_bak.conf 备份原有的配置文件文件，在nginx的根目录下创建www 目录，并使用echo 01 &gt; index.html 命令，在www目录下创建index.html，作为HttpServer的静态资源。 删除nginx.conf 的内容并写入如下配置： 12345678910111213worker_processes 1;events { worker_connections 1024;}error_log D:/nginx-1.14.0/error.log;http { access_log D:/nginx-1.14.0/access.log; server { location / { root D:/nginx-1.14.0/www; } }} ​ 打开浏览器输入http://localhost/ 结果如下图： ​ ​ 至此， 配置Nginx最基本的功能已经成功运行 Nginx配置文件Nginx配置文件中配置项有两种结构 简单指令（simple directive），形如key value; 块指令（block directive）， 形如key {simple_key simple_value;} 块指令中包含有简单指令。 形如json，又不是json 1234worker_processes 1;events { worker_connections 1024;} worker_processes 为工作进程的数量，这里如果不填的话默认为CPU核心数，事实上数量为CPU核心数也是最优配置，因为此时，理论上操作系统发生进程切换的的代价最小。 events.worker_connections 每个工作进程的最大连接数，events有很多复杂的配置，详情点击这里 error_log 为发生错误时的日志输出路径 1234567http { access_log D:/Tools/nginx-1.17.0/logs/access.log; server { location / { root D:/Tools/nginx-1.17.0/www; } } 这一部分是映射的主体，包含在一个块级指令http{}中，access_log指定该http的日志路径 （也可配置在server{}内），所有server访问日志都会输出到此。server{}内有location / {}项，nginx会根据location后面的路径和ip:port/path中的path做匹配，如果匹配到， 则从里面配置的D:/Tools/nginx-1.17.0/www本地目录下寻找请求的资源。 注意：一个server{}下可以有多个location配置，且location配置可以跟正则表达式，如下： 1234567891011server { location / { root D:/Tools/nginx-1.17.0/www; } location /static/ { root D:/Tools/nginx-1.17.0/static; } location ~ \\.(gif|jpg|png)${ root D:/Tools/nginx-1.17.0/images; }} nginx的匹配优先级为：正则、长路径、短路径。正则必须以~开头，后面跟要匹配的文件名正则表达式，这里以localhost/01.png为例， nginx会找到符合文件名的第三项配置，然后会从D:/Tools/nginx-1.17.0/images中找01.png文件，这里没有任何问题。 如果路径 为/static/file.suffix，匹配到location /之后，还会往更深的location /static/配置的root目录下匹配资源，此时会在本地找到D:/Tools/nginx-1.17.0/static/file.suffix文件。此时如果删除location /static/的配置，就会从location /的root目录下寻找配置文件，即此时的匹配路径为D:/Tools/nginx-1.17.0/www/static/file.suffix。这点符合nginx优先匹配深层次的location配置这一特性。 有意思的是当路径为/static/01.png时，此时符合location ~ \\.(gif|jpg|png)$和location /static/两项配置，但由于正则优先，会寻找本地文件系统中D:/Tools/nginx-1.17.0/images/static/01.png文件 。 Nginx作为代理服务器Nginx经常作为代理服务器，作为代理的访问逻辑如下图： 这里将上面配置好的静态文件服务器作为目标WebServer，首先将配置文件的http{}块中追加以下内容 ： 123456server { listen 8080; location / { proxy_pass http://localhost:80; }} 然后使用nginx -s reload重新加载配置文件，在浏览器中输入localhost:8080/index.html可以看到浏览器输出如下： 这里对上面的配置进行简单解释： server{listen 8080;}表明启动一个http-server监听在8080端口（注：此项不填默认为80端口，但前面的静态服务器已经占用了80端口，此处就为其他端口）。 location / {proxy_pass http://localhost:80;} location的匹配规则前文已经讲过，这里当匹配上location /之后，就会从请求proxy_pass的URL，然后在将结果返回给浏览器。此时的localhost:8080/index.html请求相当于在请求localhost:80/index.html Nginx负载均衡 工作原理Nginx配置负载均衡工作在TCP/IP协议的第七层，即应用层，属于七层负载均衡。 Nginx使用反向代理达到负载均衡 负载均衡策略nginx的负载均衡策略可以划分为两大类：内置策略和扩展策略。 内置策略包含加权轮询和ip hash，在默认情况下这两种策略会编译进nginx内核，只需在nginx配置中指明参数即可。 扩展策略有很多，如fair、通用hash、consistent hash等，默认不编译进nginx内核 。 轮询策略轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。Weight 指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。 ip_hash策略ip_hash：每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。但目前大部份应用的客户端都是共享上网方式，所以此策略在实际运用过程中，往往达不到效果。 扩展策略fair：这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块 ​ fair：这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块 负载均衡的优点提高系统吞吐量 通过负载均衡，部署多个tomcat服务，提高系统的吞吐量 降低单点故障 有效降低单点故障率，故障率随着后端服务的部署增多而下降，同时通过对HTTP报头的检查，自定义400\\500等错误显示页面，提供更友好服务 降低对外网端口的依赖 负载均衡下只需要一个外网端口，但可以负载到内网多个tomcat上 降低网络带宽 通过nginx的动静资源分离root、缓存加速proxy_cache_path、压缩GZIP、客户端缓 存expires等功能，减少数据传输量，降低带宽要求 不停机升级系统 很多情况下，我们升级服务端系统文件后，需要重启服务以应用最新程序，通过 Nginx负载实现不停服务完成重启 负载均衡策略 Nginx负载均衡","link":"/2019/06/18/Nginx入门学习/"}],"tags":[{"name":"Ubuntu16.04配置阿里云数据源","slug":"Ubuntu16-04配置阿里云数据源","link":"/tags/Ubuntu16-04配置阿里云数据源/"},{"name":"tag1","slug":"tag1","link":"/tags/tag1/"},{"name":"tag2","slug":"tag2","link":"/tags/tag2/"},{"name":"tag3","slug":"tag3","link":"/tags/tag3/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"}],"categories":[{"name":"默认分类","slug":"默认分类","link":"/categories/默认分类/"}]}