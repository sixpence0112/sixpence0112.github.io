{"pages":[{"title":"","text":"12# sixpence0112.github.iosixpence0112的博客","link":"/README.html"},{"title":"'intellij'","text":"","link":"/intellij/index.html"}],"posts":[{"title":"","text":"12# sixpence0112.github.iosixpence0112的博客","link":"/2019/04/28/README/"},{"title":"Linux学习杂记","text":"配置Java环境变量 配置系统环境变量 vi /etc/enviroment 打开系统配置文件 添加如下配置 123export JAVA_HOME=/usr/local/java/jdk1.8.0_211export JRE_HOME=/usr/local/java/jdk1.8.0_211/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib 配置用户环境变量 vi /etc/profile 打开系统配置文件 添加如下配置,在图片所示位置 123export JAVA_HOME=/usr/local/java/jdk1.8.0_211export JRE_HOME=/usr/local/java/jdk1.8.0_211/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib ​ tomcat安装 下载jdk对应版本tomcat：https://tomcat.apache.org/download-80.cgi 将文件放入相应目录，执行 1tar -xzvf apache-tomcat-8.5.45.tar.gz 将解压后的文件转移至目标文件夹 1mv apache-tomcat-8.5.45 /usr/local mysql安装 1.下载并安装MySQL官方的 Yum Repository 1`wget -i -c http:``//dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm` 如果 wegt 未安装的话可以先用 yum 安装 wget ： 1`yum install wget` 安装mysql57-community-release-el7-10.noarch.rpm包 1`yum -y install mysql57-community-release-el7-10.noarch.rpm` 安装这个包后，会获得两个mysql的yum repo源：/etc/yum.repos.d/mysql-community.repo，/etc/yum.repos.d/mysql-community-source.repo。 安装MySQL 1`yum -y install mysql-community-server` 至此MySQL就安装完成了，然后是对MySQL的一些设置。 修改密码 首先启动MySQL： 1`systemctl start mysqld.service` 查看mysql运行状态： 1`systemctl status mysqld.service` 找出在日志文件中的密码： 1`grep ``&quot;password&quot;` `/``var``/log/mysqld.log` 进入数据库 1`mysql -uroot -p` 输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库： 1`mysql&gt; ALTER USER ``&apos;root&apos;``@``&apos;localhost&apos;` `IDENTIFIED BY ``&apos;new password&apos;``;` ​ 修改密码设置策略 1set global validate_password_policy=0;","link":"/2019/08/22/Linux学习杂记/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/04/24/hello-world/"},{"title":"'intellij'","text":"ctrl+alt+t ：try/if等快捷键","link":"/2019/05/18/intellij/"},{"title":"'jsp页面获取session值'","text":"​ jsp页面获取session值java代码 12345678910@RequestMapping(value = &quot;/chkUser&quot;,method = RequestMethod.POST,produces = &quot;application/json;charset=UTF-8&quot;) public String chkUserInfo(HttpServletRequest request,String userName, String userPwd){ if(StringUtils.isBlank(userName)||StringUtils.isBlank(userPwd)) return &quot;false&quot;; UserEntity entity = chkLoginService.chkUserService(userName,userPwd); if(entity==null) return &quot;false&quot;; request.getSession().setAttribute(&quot;userEntity&quot;,entity); return &quot;true&quot;; } 方法一jsp页面使用 request.getSession().getAttribute(“**“) 方法 方法二在jsp页面 script中使用EL表达式获取var userEntity=’${sessionScope.userEntity.loginName}’;说明1、sessionScope指的是session的范围，类似还有requestScope，pageScope,contextScope 2、sessionScope整体的意思是获得存放在session.setAttrbute(key,value)的值即session.getAttribute(key) 原文：https://blog.csdn.net/xiongdaandxiaomi/article/details/80593244","link":"/2019/06/18/jsp页面获取session值/"},{"title":"@Scheduled参数详解","text":"参数详解1. cron该参数接收一个cron表达式，cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义。 cron表达式语法1[秒] [分] [小时] [日] [月] [周] [年] 注：[年]不是必须的域，可以省略[年]，则一共6个域 序号 说明 必填 允许填写的值 允许的通配符 1 秒 是 0-59 , - * / 2 分 是 0-59 , - * / 3 时 是 0-23 , - * / 4 日 是 1-31 , - * ? / L W 5 月 是 1-12 / JAN-DEC , - * / 6 周 是 1-7 or SUN-SAT , - * ? / L # 7 年 否 1970-2099 , - * / 通配符说明: * 表示所有值。 例如:在分的字段上设置 *,表示每一分钟都会触发。 ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ? - 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。 , 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发 / 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。 L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五” W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)。 # 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：’L’和 ‘W’可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON与mon相同。 示例每隔5秒执行一次：/5 * ? 每隔1分钟执行一次：0 /1 ? 每天23点执行一次：0 0 23 ? 每天凌晨1点执行一次：0 0 1 ? 每月1号凌晨1点执行一次：0 0 1 1 * ? 每月最后一天23点执行一次：0 0 23 L * ? 每周星期天凌晨1点实行一次：0 0 1 ? * L 在26分、29分、33分执行一次：0 26,29,33 * ? 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 ? cron表达式使用占位符另外，cron属性接收的cron表达式支持占位符。eg： 配置文件： 123time: cron: */5 * * * * * interval: 5 每5秒执行一次： 123456789@Scheduled(cron=\"${time.cron}\")void testPlaceholder1() { System.out.println(\"Execute at \" + System.currentTimeMillis());}@Scheduled(cron=\"*/${time.interval} * * * * *\")void testPlaceholder2() { System.out.println(\"Execute at \" + System.currentTimeMillis());} 2. zone时区，接收一个java.util.TimeZone#ID。cron表达式会基于该时区解析。默认是一个空字符串，即取服务器所在地的时区。比如我们一般使用的时区Asia/Shanghai。该字段我们一般留空。 3. fixedDelay上一次执行完毕时间点之后多长时间再执行。如： 1@Scheduled(fixedDelay = 5000) //上一次执行完毕时间点之后5秒再执行 4. fixedDelayString与 3. fixedDelay 意思相同，只是使用字符串的形式。唯一不同的是支持占位符。如： 1@Scheduled(fixedDelayString = \"5000\") //上一次执行完毕时间点之后5秒再执行 占位符的使用(配置文件中有配置：time.fixedDelay=5000)： 1234@Scheduled(fixedDelayString = \"${time.fixedDelay}\")void testFixedDelayString() { System.out.println(\"Execute at \" + System.currentTimeMillis());} 运行结果： 占位符的使用 5. fixedRate上一次开始执行时间点之后多长时间再执行。如： 1@Scheduled(fixedRate = 5000) //上一次开始执行时间点之后5秒再执行 6. fixedRateString与 5. fixedRate 意思相同，只是使用字符串的形式。唯一不同的是支持占位符。 7. initialDelay第一次延迟多长时间后再执行。如： 1@Scheduled(initialDelay=1000, fixedRate=5000) //第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次 8. initialDelayString与 7. initialDelay 意思相同，只是使用字符串的形式。唯一不同的是支持占位符。","link":"/2019/09/11/Scheduled参数详解/"},{"title":"js监听input框","text":"onpropertychange： IE下，当一个HTML元素的属性改变的时候，都能通过 onpropertychange来即时捕获。onchange在属性值改变时还必须使得当前元素失去焦点(onblur)才可以激活该事件。 在用js脚本改动该元素值时候亦能触发onpropertychange事件。oninput：是onpropertychange的非IE浏览器版本，支持firefox和opera等浏览器，但有一点不同，它绑定于对象时，并非该对象所有属性改变都能触发事件，它只在对象value值发生改变时奏效。 onchange： (a)当前对象属性改变，并且是由键盘或鼠标事件激发的（脚本触发无效）；(b)当前对象失去焦点(onblur) ； jQuery用法$(&quot;#input1&quot;).bind(&quot;input propertychange&quot;,function(event){ console.log($(&quot;#input1&quot;).val()) }); 原生Js用法123456789101112131415 &lt;script type=&quot;text/javascript&quot;&gt; // Firefox, Google Chrome, Opera, Safari, Internet Explorer from version 9 function OnInput (event) { alert (&quot;The new content: &quot; + event.target.value); } // Internet Explorer function OnPropChanged (event) { if (event.propertyName.toLowerCase () == &quot;value&quot;) { alert (&quot;The new content: &quot; + event.srcElement.value); } } &lt;/script&gt; //Input标签&lt;input type=&quot;text&quot; oninput=&quot;OnInput (event)&quot; onpropertychange=&quot;OnPropChanged (event)&quot; value=&quot;Text field&quot; /&gt;","link":"/2019/06/03/js监听input框/"},{"title":"postName","text":"12","link":"/2013/12/02/my-first-blog/"},{"title":"linux修改只读文件","text":"Linux 修改只读文件进入文件所在位置 — 例如：cd /etc （在etc文件夹下有文件hosts）查看文件 — 命令：vim host 然后enter编辑该文件 — 点击insert，就可以编辑了，上下箭头移动到要编辑的位置保存文件 — 按下Esc，之后，键入命令：:w !sudo tee %，输入密码然后，警告文件已被修改了，并显示出一个选项菜单。这里按 L键重新将该文件载入缓冲区。Press ENTER or type command to continueW12: Warning: File “/etc/profile” has changed and the buffer was changed in Vim as wellSee “:help W12” for more info. [O]K, (L)oad File:","link":"/2019/05/06/linux修改只读文件/"},{"title":"tomcat配置IP访问;","text":"1、修改背景：A、通常我们访问我们的web应用格式为： 1http://ip:端口号/项目名称 例如： 1http://127.0.0.1:8080/projectName B、如果想直接输入“本地ip”直接进入应用，该如何设置呢？如下面URL： 1http://127.0.0.1 2、修改tomcat默认端口号、默认项目（应用）名称：A、先将tomcat的默认端口“8080”改为缺省的端口号“80：需要修改”tomcat”根目录下的”conf”目录下的”server.xml”文件” 1&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 把上面标签中”port”属性”8080”修改为”80”即可（访问url可以不输入端口号）。 备注：tomcat默认端口号为8080，http服务的默认端口号为80。在浏览器地址栏输入ip或者域名之后，如果不输入端口号，默认就是80端口。 2、设置默认应用(这里用到一个小技巧，注释掉的默认应用配置，默认输入ip就去访问Tomcat主页) A：注释如下： 备注：如果不配置标签,由于没有docBase指明项目位置，则项目必须放在host配置中对应的appBase地址下（如webapps）,Tomcat启动时会加载webapps下所有项目，且没有path指引时，默认指引是项目名称。就会访问Tomcat ROOT下的web.xml index.jsp 主页(index.jsp)(因为Tomacat主页是ROOT文件夹下的)。 B：修改ROOT下的index.jsp文件 &lt;%response.sendRedirect(“/myProject/index.html”);//myProject这里就是我们不熟的项目名称了。%&gt;","link":"/2019/07/27/tomcat配置IP访问/"},{"title":"'linux命令''","text":"sudo chmod -R 777 /工作目录 获取工作目录下的文件操作权限（解决permission denied问题） ps -ef |grep tomcat 产看进程，grep后边可跟应用名或者端口号 tail -f logs/catalina.out 查看tomcat日志，须在tomcat目录下执行 cp -r userfiles /home 复制文件userfiles到/home目录下 netstat -anp |grep 端口号 查看端口占用 netstat -nultp 查看当前所有已经使用的端口情况 firewall-cmd –state 查看防火墙运行状态 start firewalld.service 启动防火墙 firewall-cmd –permanent –zone=public –add-port=8080-8081/tcp 开放某个端口 firewall-cmd –permanent –zone=public –add-service=https 开启服务 firewall-cmd –permanent –zone=public –list-services //服务空格隔开 查看开启的服务 firewall-cmd –permanent –zone=public –list-ports //端口空格隔开 查看开启的端口 iptables -L -n | grep 21 检查设定是否生效 ps -ef|grep tomcat 查看程序启动情况","link":"/2019/05/20/linux命令/"},{"title":"待学习","text":"函数式接口 lambda公式","link":"/2019/08/30/待学习/"},{"title":"一些注解的说明","text":"@EnableConfigurationProperties 使使用 @ConfigurationProperties 注解的类生效。 如果一个配置类只配置@ConfigurationProperties注解，而没有使用@Component，那么在IOC容器中是获取不到properties 配置文件转化的bean。说白了 @EnableConfigurationProperties 相当于把使用 @ConfigurationProperties 的类进行了一次注入。 @ConfigurationProperties 将配置文件application.properties中配置的每一个属性值映射到当前类的属性中； @ConfigurationProperties：告诉springboot将本类中所有属性和配置文件中相关的配置进行绑定；prefix=”person”：指出将配置文件中person下的所有属性进行一一映射； @Value @Value(“${person.last-name}”) 从配置文件中获取值","link":"/2019/09/10/一些注解的说明/"},{"title":"'开启/关闭Ubuntu防火墙'","text":"安装方法1sudo apt-get install ufw 当然，这是有图形界面的(比较简陋)，在新立得里搜索gufw试试…… 使用方法1 启用 1sudo ufw enable 1sudo ufw default deny 作用：开启了防火墙并随系统启动同时关闭所有外部对本机的访问（本机访问外部正常）。 2 关闭 1sudo ufw disable 2 查看防火墙状态 1sudo ufw status 3 开启/禁用相应端口或服务举例 1sudo ufw allow 80 允许外部访问80端口 1sudo ufw delete allow 80 禁止外部访问80 端口 1sudo ufw allow from 192.168.1.1 允许此IP访问所有的本机端口 1sudo ufw deny smtp 禁止外部访问smtp服务 1sudo ufw delete allow smtp 删除上面建立的某条规则 1sudo ufw deny proto tcp from 10.0.0.0/8 to 192.168.0.1 port 22 要拒绝所有的TCP流量从10.0.0.0/8 到192.168.0.1地址的22端口 1234 可以允许所有RFC1918网络（局域网/无线局域网的）访问这个主机（/8,/16,/12是一种网络分级）：sudo ufw allow from 10.0.0.0/8sudo ufw allow from 172.16.0.0/12sudo ufw allow from 192.168.0.0/16 推荐设置1sudo apt-get install ufw 1sudo ufw enable 1sudo ufw default deny 这样设置已经很安全，如果有特殊需要，可以使用sudo ufw allow开启相应服务。","link":"/2019/05/08/开启-关闭Ubuntu防火墙/"},{"title":"Docker学习--Nexus服务搭建","text":"docker hub 上找到 sonatype/nexus 镜像 1docker pull sonatype/nexus:版本号 编写nexus-compose.yml文件 12345678910version: &apos;2&apos;services: nexus: image: sonatype/nexus:2.14.5 restart: always container_name: nexus ports: - &apos;8081:8081&apos; volumes: - /usr/local/docker/nexus/data:/nexus-data 启动 1docker-compose up -d 配置认证信息 在Maven setting.xml中添加Nexus认证信息（servers 节点下） 1234567891011&lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 配置自动化部署 在pom.xml中添加 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;user-release&lt;/id&gt; &lt;name&gt;user release resp&lt;/name&gt; &lt;url&gt;http://192.168.44.128:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;name&gt;user snapshots resp&lt;/name&gt; &lt;url&gt;http://192.168.44.128:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 配置代理仓库 在pom.xml中添加 1234567891011121314151617181920212223242526&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Repository&lt;/name&gt; &lt;url&gt;http://192.168.172.141:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;Nexus Plugin Repository&lt;/name&gt; &lt;url&gt;http://192.168.172.141:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;","link":"/2019/09/28/Docker学习-Nexus服务搭建/"},{"title":"Mybatis-Plus学习","text":"这是一片关于Mybatis-Plus的学习笔记，记录学习的过程与感悟。仅适用于自身。 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt;&lt;/dependency&gt; 123 WARNING引入 `MyBatis-Plus` 之后请不要再次引入 `MyBatis` 以及 `MyBatis-Spring`，以避免因版本差异导致的问题 2.在application.yml文件中添加配置 123456789#mybatis plus 设置mybatis-plus: type-aliases-package: cc.mrbird.febs.system.domain,cc.mrbird.febs.job.domain mapper-locations: classpath:mapper/*/*.xml configuration: jdbc-type-for-null: null global-config: # 关闭 mybatis-plus的 banner banner: false typeAliasesPackage​ MyBaits 别名包扫描路径，通过该属性可以给包中的类注册别名，注册后在 Mapper 对应的 XML 文件中可以直接使用类名，而不用使用全限定的类名（即 XML 中调用的时候不用包含包名）。 ​ 例如： 1&lt;select id=&quot;queryList&quot; resultType=&quot;job&quot;&gt;&lt;/select&gt; typeAliasesSuperType​ 该配置请和 typeAliasesPackage 一起使用，如果配置了该属性，则仅仅会扫描路径下以该类作为父类的域对象 。 功能 代码生成 参照官方文档进行配置，基本不会出幺蛾子。模板选项有freemarker，String templatePath = &quot;/templates/mapper.xml.ftl&quot; 和velocity， String templatePath = &quot;/templates/mapper.xml.vm&quot; 也可自定义模板。代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 数据库 URLprivate static final String URL = &quot;jdbc:mysql://127.0.0.1:3306/sixpence?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&quot;;// 数据库驱动private static final String DRIVER_NAME = &quot;com.mysql.jdbc.Driver&quot;;// 数据库用户名private static final String USERNAME = &quot;root&quot;;// 数据库密码private static final String PASSWORD = &quot;root&quot;;// @author 值private static final String AUTHOR = &quot;sixpence&quot;;// 包的基础路径private static final String BASE_PACKAGE_URL = &quot;com.sixpence.mp&quot;;// xml文件路径private static final String XML_PACKAGE_URL = &quot;/src/main/resources/mapper/&quot;;// xml 文件模板private static final String XML_MAPPER_TEMPLATE_PATH = &quot;generator/templates/mapper.xml&quot;;// mapper 文件模板private static final String MAPPER_TEMPLATE_PATH = &quot;generator/templates/mapper.java&quot;;// entity 文件模板private static final String ENTITY_TEMPLATE_PATH = &quot;generator/templates/entity.java&quot;;// service 文件模板private static final String SERVICE_TEMPLATE_PATH = &quot;generator/templates/service.java&quot;;// serviceImpl 文件模板private static final String SERVICE_IMPL_TEMPLATE_PATH = &quot;generator/templates/serviceImpl.java&quot;;// controller 文件模板private static final String CONTROLLER_TEMPLATE_PATH = &quot;generator/templates/controller.java&quot;;public static void main(String[] args) { // 代码生成器 AutoGenerator generator = new AutoGenerator(); // 全局配置 GlobalConfig globalConfig = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); globalConfig.setOutputDir(projectPath + &quot;/src/main/java&quot;); globalConfig.setAuthor(AUTHOR); globalConfig.setOpen(false); globalConfig.setFileOverride(false); generator.setGlobalConfig(globalConfig); // 数据源配置 DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setUrl(URL); // dataSourceConfig.setSchemaName(&quot;public&quot;); dataSourceConfig.setDriverName(DRIVER_NAME); dataSourceConfig.setUsername(USERNAME); dataSourceConfig.setPassword(PASSWORD); generator.setDataSource(dataSourceConfig); // 包配置 PackageConfig packageConfig = new PackageConfig(); packageConfig.setModuleName(&quot;gen&quot;); packageConfig.setParent(BASE_PACKAGE_URL); generator.setPackageInfo(packageConfig); // 配置自定义代码模板 TemplateConfig templateConfig = new TemplateConfig(); templateConfig.setXml(XML_MAPPER_TEMPLATE_PATH); templateConfig.setMapper(MAPPER_TEMPLATE_PATH); templateConfig.setEntity(ENTITY_TEMPLATE_PATH); templateConfig.setService(SERVICE_TEMPLATE_PATH); templateConfig.setServiceImpl(SERVICE_IMPL_TEMPLATE_PATH); templateConfig.setController(CONTROLLER_TEMPLATE_PATH); generator.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); //strategy.setSuperEntityClass(&quot;com.baomidou.ant.common.BaseEntity&quot;); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); //strategy.setSuperControllerClass(&quot;com.baomidou.ant.common.BaseController&quot;); strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;)); strategy.setSuperEntityColumns(&quot;id&quot;); strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(packageConfig.getModuleName() + &quot;_&quot;); generator.setStrategy(strategy); generator.setTemplateEngine(new FreemarkerTemplateEngine()); generator.execute();}private static String scanner(String tip) { Scanner scanner = new Scanner(System.in); System.out.println((&quot;请输入&quot; + tip + &quot;：&quot;)); if (scanner.hasNext()) { String ipt = scanner.next(); if (StringUtils.isNotBlank(ipt)) return ipt; } throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;);} CRUD接口 Mapper的CRUD接口 说明: 通用 CRUD 封装BaseMapper接口，为 Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器 泛型 T 为任意实体对象 参数 Serializable 为任意类型主键 Mybatis-Plus 不推荐使用复合主键约定每一张表都有自己的唯一 id 主键 对象 Wrapper 为 条件构造器 以下为部分接口方法： insert 123456789/** * &lt;p&gt; * 插入一条记录 * &lt;/p&gt; * * @param entity 实体对象 * @return 插入成功记录数 */int insert(T entity); - delete 123456789/** * &lt;p&gt; * 根据 entity 条件，删除记录 * &lt;/p&gt; * * @param wrapper 实体对象封装操作类（可以为 null） * @return 删除成功记录数 */int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper); - updateById 123456789/** * &lt;p&gt; * 根据 ID 修改 * &lt;/p&gt; * * @param entity 实体对象 * @return 修改成功记录数 */int updateById(@Param(Constants.ENTITY) T entity); - selectMaps 123456789/** * &lt;p&gt; * 根据 Wrapper 条件，查询全部记录 * &lt;/p&gt; * * @param queryWrapper 实体对象封装操作类（可以为 null） * @return 字段映射对象 Map 集合 */List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); Service的CRUD接口 说明: 通用 Service CRUD 封装IService接口，进一步封装 CRUD 采用 get 查询单行 remove 删除`list 查询集合page 分页前缀命名方式区分Mapper` 层避免混淆， 泛型 T 为任意实体对象 建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类 对象 Wrapper 为 条件构造器 关于接口内容不再赘述，偶需要看文档。 条件构造器 详见文档 分页插件 1234567&lt;!-- spring xml 方式 --&gt;&lt;plugins&gt; &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;&gt; &lt;property name=&quot;sqlParser&quot; ref=&quot;自定义解析类、可以没有&quot; /&gt; &lt;property name=&quot;dialectClazz&quot; value=&quot;自定义方言类、可以没有&quot; /&gt; &lt;/plugin&gt;&lt;/plugins&gt; 1234567891011121314//Spring boot方式@EnableTransactionManagement@Configuration@MapperScan(&quot;com.baomidou.cloud.service.*.mapper*&quot;)public class MybatisPlusConfig { /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); }} 自定义分页 UserMapper.java方法内容 12345678910111213public interface UserMapper{//可以继承或者不继承BaseMapper /** * &lt;p&gt; * 查询 : 根据state状态查询用户列表，分页显示 * 注意!!: 如果入参是有多个,需要加注解指定参数名才能在xml中取值 * &lt;/p&gt; * * @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位(你可以继承Page实现自己的分页对象) * @param state 状态 * @return 分页对象 */ IPage&lt;User&gt; selectPageVo(Page page, @Param(&quot;state&quot;) Integer state);} UserMapper.xml编写一个list查询 123&lt;select id=&quot;selectPageVo&quot; resultType=&quot;com.baomidou.cloud.entity.UserVo&quot;&gt; SELECT id,name FROM user WHERE state=#{state}&lt;/select&gt; UserServiceImpl调用分页方法 1234567public IPage&lt;User&gt; selectUserPage(Page&lt;User&gt; page, Integer state) { // 不进行 count sql 优化，解决 MP 无法自动优化 SQL 问题，这时候你需要自己查询 count 部分 // page.setOptimizeCountSql(false); // 当 total 为非 0 时(默认为 0),分页插件不会进行 count 查询 // 要点!! 分页返回的对象与传入的对象是同一个 return userMapper.selectPageVo(page, state);} 代码示例如下： 123456789101112131415161718192021222324252627282930313233public class PaginationTest { @Resource private UserMapper mapper; @Test public void tests() { System.out.println(&quot;----- baseMapper 自带分页 ------&quot;); Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); IPage&lt;User&gt; userIPage = mapper.selectPage(page, new QueryWrapper&lt;User&gt;() .eq(&quot;age&quot;, 20).eq(&quot;name&quot;, &quot;Jack&quot;)); assertThat(page).isSameAs(userIPage); System.out.println(&quot;总条数 ------&gt; &quot; + userIPage.getTotal()); System.out.println(&quot;当前页数 ------&gt; &quot; + userIPage.getCurrent()); System.out.println(&quot;当前每页显示数 ------&gt; &quot; + userIPage.getSize()); print(userIPage.getRecords()); System.out.println(&quot;----- baseMapper 自带分页 ------&quot;); System.out.println(&quot;json 正反序列化 begin&quot;); String json = JSON.toJSONString(page); Page&lt;User&gt; page1 = JSON.parseObject(json, TypeBuilder.newInstance(Page.class).addTypeParam(User.class).build()); print(page1.getRecords()); System.out.println(&quot;json 正反序列化 end&quot;); System.out.println(&quot;----- 自定义 XML 分页 ------&quot;); MyPage&lt;User&gt; myPage = new MyPage&lt;User&gt;(1, 5).setSelectInt(20).setSelectStr(&quot;Jack&quot;); ParamSome paramSome = new ParamSome(20, &quot;Jack&quot;); MyPage&lt;User&gt; userMyPage = mapper.mySelectPage(myPage, paramSome); assertThat(myPage).isSameAs(userMyPage); System.out.println(&quot;总条数 ------&gt; &quot; + userMyPage.getTotal()); System.out.println(&quot;当前页数 ------&gt; &quot; + userMyPage.getCurrent()); System.out.println(&quot;当前每页显示数 ------&gt; &quot; + userMyPage.getSize()); print(userMyPage.getRecords()); System.out.println(&quot;----- 自定义 XML 分页 ------&quot;); } ### sql分析打印 ​ 该功能依赖 `p6spy` 组件，完美的输出打印 SQL 及执行时长 `3.1.0` 以上版本 - p6spy 依赖引入 12345&lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; - application.yml配置 12345spring: datasource: dynamic: # 是否开启 SQL日志输出，生产环境建议关闭，有性能损耗 p6spy: true - spy.properties配置 12345678910111213# p6spy配置，文档 https://p6spy.readthedocs.io/en/latest/configandusage.html# 使用日志系统记录 sqlappender=com.p6spy.engine.spy.appender.Slf4JLogger# 自定义日志打印logMessageFormat=cc.mrbird.febs.common.config.P6spySqlFormatConfig# 是否开启慢 SQL记录outagedetection=true# 慢 SQL记录标准 2 秒outagedetectioninterval=2# 开启过滤filter=true# 包含 QRTZ的不打印exclude=QRTZ","link":"/2019/04/26/Mybatis-Plus学习/"}],"tags":[{"name":"tag1","slug":"tag1","link":"/tags/tag1/"},{"name":"tag2","slug":"tag2","link":"/tags/tag2/"},{"name":"tag3","slug":"tag3","link":"/tags/tag3/"}],"categories":[{"name":"默认分类","slug":"默认分类","link":"/categories/默认分类/"}]}