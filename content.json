{"pages":[{"title":"","text":"12# sixpence0112.github.iosixpence0112的博客","link":"/README.html"},{"title":"'intellij'","text":"","link":"/intellij/index.html"}],"posts":[{"title":"","text":"12# sixpence0112.github.iosixpence0112的博客","link":"/2019/04/28/README/"},{"title":"'intellij'","text":"ctrl+alt+t ：try/if等快捷键","link":"/2019/05/18/intellij/"},{"title":"'jsp页面获取session值'","text":"​ jsp页面获取session值java代码 12345678910@RequestMapping(value = &quot;/chkUser&quot;,method = RequestMethod.POST,produces = &quot;application/json;charset=UTF-8&quot;) public String chkUserInfo(HttpServletRequest request,String userName, String userPwd){ if(StringUtils.isBlank(userName)||StringUtils.isBlank(userPwd)) return &quot;false&quot;; UserEntity entity = chkLoginService.chkUserService(userName,userPwd); if(entity==null) return &quot;false&quot;; request.getSession().setAttribute(&quot;userEntity&quot;,entity); return &quot;true&quot;; } 方法一jsp页面使用 request.getSession().getAttribute(“**“) 方法 方法二在jsp页面 script中使用EL表达式获取var userEntity=’${sessionScope.userEntity.loginName}’;说明1、sessionScope指的是session的范围，类似还有requestScope，pageScope,contextScope 2、sessionScope整体的意思是获得存放在session.setAttrbute(key,value)的值即session.getAttribute(key) 原文：https://blog.csdn.net/xiongdaandxiaomi/article/details/80593244","link":"/2019/06/18/jsp页面获取session值/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/04/24/hello-world/"},{"title":"'linux命令''","text":"sudo chmod -R 777 /工作目录 获取工作目录下的文件操作权限（解决permission denied问题） ps -ef |grep tomcat 产看进程，grep后边可跟应用名或者端口号 tail -f logs/catalina.out 查看tomcat日志，须在tomcat目录下执行 cp -r userfiles /home 复制文件userfiles到/home目录下","link":"/2019/05/20/linux命令/"},{"title":"postName","text":"12","link":"/2013/12/02/my-first-blog/"},{"title":"tomcat配置IP访问;","text":"1、修改背景：A、通常我们访问我们的web应用格式为： 1http://ip:端口号/项目名称 例如： 1http://127.0.0.1:8080/projectName B、如果想直接输入“本地ip”直接进入应用，该如何设置呢？如下面URL： 1http://127.0.0.1 2、修改tomcat默认端口号、默认项目（应用）名称：A、先将tomcat的默认端口“8080”改为缺省的端口号“80：需要修改”tomcat”根目录下的”conf”目录下的”server.xml”文件” 1&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 把上面标签中”port”属性”8080”修改为”80”即可（访问url可以不输入端口号）。 备注：tomcat默认端口号为8080，http服务的默认端口号为80。在浏览器地址栏输入ip或者域名之后，如果不输入端口号，默认就是80端口。 2、设置默认应用(这里用到一个小技巧，注释掉的默认应用配置，默认输入ip就去访问Tomcat主页) A：注释如下： 备注：如果不配置标签,由于没有docBase指明项目位置，则项目必须放在host配置中对应的appBase地址下（如webapps）,Tomcat启动时会加载webapps下所有项目，且没有path指引时，默认指引是项目名称。就会访问Tomcat ROOT下的web.xml index.jsp 主页(index.jsp)(因为Tomacat主页是ROOT文件夹下的)。 B：修改ROOT下的index.jsp文件 &lt;%response.sendRedirect(“/myProject/index.html”);//myProject这里就是我们不熟的项目名称了。%&gt;","link":"/2019/07/27/tomcat配置IP访问/"},{"title":"js监听input框","text":"onpropertychange： IE下，当一个HTML元素的属性改变的时候，都能通过 onpropertychange来即时捕获。onchange在属性值改变时还必须使得当前元素失去焦点(onblur)才可以激活该事件。 在用js脚本改动该元素值时候亦能触发onpropertychange事件。oninput：是onpropertychange的非IE浏览器版本，支持firefox和opera等浏览器，但有一点不同，它绑定于对象时，并非该对象所有属性改变都能触发事件，它只在对象value值发生改变时奏效。 onchange： (a)当前对象属性改变，并且是由键盘或鼠标事件激发的（脚本触发无效）；(b)当前对象失去焦点(onblur) ； jQuery用法$(&quot;#input1&quot;).bind(&quot;input propertychange&quot;,function(event){ console.log($(&quot;#input1&quot;).val()) }); 原生Js用法123456789101112131415 &lt;script type=&quot;text/javascript&quot;&gt; // Firefox, Google Chrome, Opera, Safari, Internet Explorer from version 9 function OnInput (event) { alert (&quot;The new content: &quot; + event.target.value); } // Internet Explorer function OnPropChanged (event) { if (event.propertyName.toLowerCase () == &quot;value&quot;) { alert (&quot;The new content: &quot; + event.srcElement.value); } } &lt;/script&gt; //Input标签&lt;input type=&quot;text&quot; oninput=&quot;OnInput (event)&quot; onpropertychange=&quot;OnPropChanged (event)&quot; value=&quot;Text field&quot; /&gt;","link":"/2019/06/03/js监听input框/"},{"title":"linux修改只读文件","text":"Linux 修改只读文件进入文件所在位置 — 例如：cd /etc （在etc文件夹下有文件hosts）查看文件 — 命令：vim host 然后enter编辑该文件 — 点击insert，就可以编辑了，上下箭头移动到要编辑的位置保存文件 — 按下Esc，之后，键入命令：:w !sudo tee %，输入密码然后，警告文件已被修改了，并显示出一个选项菜单。这里按 L键重新将该文件载入缓冲区。Press ENTER or type command to continueW12: Warning: File “/etc/profile” has changed and the buffer was changed in Vim as wellSee “:help W12” for more info. [O]K, (L)oad File:","link":"/2019/05/06/linux修改只读文件/"},{"title":"'开启/关闭Ubuntu防火墙'","text":"安装方法1sudo apt-get install ufw 当然，这是有图形界面的(比较简陋)，在新立得里搜索gufw试试…… 使用方法1 启用 1sudo ufw enable 1sudo ufw default deny 作用：开启了防火墙并随系统启动同时关闭所有外部对本机的访问（本机访问外部正常）。 2 关闭 1sudo ufw disable 2 查看防火墙状态 1sudo ufw status 3 开启/禁用相应端口或服务举例 1sudo ufw allow 80 允许外部访问80端口 1sudo ufw delete allow 80 禁止外部访问80 端口 1sudo ufw allow from 192.168.1.1 允许此IP访问所有的本机端口 1sudo ufw deny smtp 禁止外部访问smtp服务 1sudo ufw delete allow smtp 删除上面建立的某条规则 1sudo ufw deny proto tcp from 10.0.0.0/8 to 192.168.0.1 port 22 要拒绝所有的TCP流量从10.0.0.0/8 到192.168.0.1地址的22端口 1234 可以允许所有RFC1918网络（局域网/无线局域网的）访问这个主机（/8,/16,/12是一种网络分级）：sudo ufw allow from 10.0.0.0/8sudo ufw allow from 172.16.0.0/12sudo ufw allow from 192.168.0.0/16 推荐设置1sudo apt-get install ufw 1sudo ufw enable 1sudo ufw default deny 这样设置已经很安全，如果有特殊需要，可以使用sudo ufw allow开启相应服务。","link":"/2019/05/08/开启-关闭Ubuntu防火墙/"},{"title":"Mybatis-Plus学习","text":"这是一片关于Mybatis-Plus的学习笔记，记录学习的过程与感悟。仅适用于自身。 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt;&lt;/dependency&gt; 123 WARNING引入 `MyBatis-Plus` 之后请不要再次引入 `MyBatis` 以及 `MyBatis-Spring`，以避免因版本差异导致的问题 2.在application.yml文件中添加配置 123456789#mybatis plus 设置mybatis-plus: type-aliases-package: cc.mrbird.febs.system.domain,cc.mrbird.febs.job.domain mapper-locations: classpath:mapper/*/*.xml configuration: jdbc-type-for-null: null global-config: # 关闭 mybatis-plus的 banner banner: false typeAliasesPackage​ MyBaits 别名包扫描路径，通过该属性可以给包中的类注册别名，注册后在 Mapper 对应的 XML 文件中可以直接使用类名，而不用使用全限定的类名（即 XML 中调用的时候不用包含包名）。 ​ 例如： 1&lt;select id=&quot;queryList&quot; resultType=&quot;job&quot;&gt;&lt;/select&gt; typeAliasesSuperType​ 该配置请和 typeAliasesPackage 一起使用，如果配置了该属性，则仅仅会扫描路径下以该类作为父类的域对象 。 功能 代码生成 参照官方文档进行配置，基本不会出幺蛾子。模板选项有freemarker，String templatePath = &quot;/templates/mapper.xml.ftl&quot; 和velocity， String templatePath = &quot;/templates/mapper.xml.vm&quot; 也可自定义模板。代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 数据库 URLprivate static final String URL = &quot;jdbc:mysql://127.0.0.1:3306/sixpence?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&quot;;// 数据库驱动private static final String DRIVER_NAME = &quot;com.mysql.jdbc.Driver&quot;;// 数据库用户名private static final String USERNAME = &quot;root&quot;;// 数据库密码private static final String PASSWORD = &quot;root&quot;;// @author 值private static final String AUTHOR = &quot;sixpence&quot;;// 包的基础路径private static final String BASE_PACKAGE_URL = &quot;com.sixpence.mp&quot;;// xml文件路径private static final String XML_PACKAGE_URL = &quot;/src/main/resources/mapper/&quot;;// xml 文件模板private static final String XML_MAPPER_TEMPLATE_PATH = &quot;generator/templates/mapper.xml&quot;;// mapper 文件模板private static final String MAPPER_TEMPLATE_PATH = &quot;generator/templates/mapper.java&quot;;// entity 文件模板private static final String ENTITY_TEMPLATE_PATH = &quot;generator/templates/entity.java&quot;;// service 文件模板private static final String SERVICE_TEMPLATE_PATH = &quot;generator/templates/service.java&quot;;// serviceImpl 文件模板private static final String SERVICE_IMPL_TEMPLATE_PATH = &quot;generator/templates/serviceImpl.java&quot;;// controller 文件模板private static final String CONTROLLER_TEMPLATE_PATH = &quot;generator/templates/controller.java&quot;;public static void main(String[] args) { // 代码生成器 AutoGenerator generator = new AutoGenerator(); // 全局配置 GlobalConfig globalConfig = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); globalConfig.setOutputDir(projectPath + &quot;/src/main/java&quot;); globalConfig.setAuthor(AUTHOR); globalConfig.setOpen(false); globalConfig.setFileOverride(false); generator.setGlobalConfig(globalConfig); // 数据源配置 DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setUrl(URL); // dataSourceConfig.setSchemaName(&quot;public&quot;); dataSourceConfig.setDriverName(DRIVER_NAME); dataSourceConfig.setUsername(USERNAME); dataSourceConfig.setPassword(PASSWORD); generator.setDataSource(dataSourceConfig); // 包配置 PackageConfig packageConfig = new PackageConfig(); packageConfig.setModuleName(&quot;gen&quot;); packageConfig.setParent(BASE_PACKAGE_URL); generator.setPackageInfo(packageConfig); // 配置自定义代码模板 TemplateConfig templateConfig = new TemplateConfig(); templateConfig.setXml(XML_MAPPER_TEMPLATE_PATH); templateConfig.setMapper(MAPPER_TEMPLATE_PATH); templateConfig.setEntity(ENTITY_TEMPLATE_PATH); templateConfig.setService(SERVICE_TEMPLATE_PATH); templateConfig.setServiceImpl(SERVICE_IMPL_TEMPLATE_PATH); templateConfig.setController(CONTROLLER_TEMPLATE_PATH); generator.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); //strategy.setSuperEntityClass(&quot;com.baomidou.ant.common.BaseEntity&quot;); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); //strategy.setSuperControllerClass(&quot;com.baomidou.ant.common.BaseController&quot;); strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;)); strategy.setSuperEntityColumns(&quot;id&quot;); strategy.setControllerMappingHyphenStyle(true); strategy.setTablePrefix(packageConfig.getModuleName() + &quot;_&quot;); generator.setStrategy(strategy); generator.setTemplateEngine(new FreemarkerTemplateEngine()); generator.execute();}private static String scanner(String tip) { Scanner scanner = new Scanner(System.in); System.out.println((&quot;请输入&quot; + tip + &quot;：&quot;)); if (scanner.hasNext()) { String ipt = scanner.next(); if (StringUtils.isNotBlank(ipt)) return ipt; } throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;);} CRUD接口 Mapper的CRUD接口 说明: 通用 CRUD 封装BaseMapper接口，为 Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器 泛型 T 为任意实体对象 参数 Serializable 为任意类型主键 Mybatis-Plus 不推荐使用复合主键约定每一张表都有自己的唯一 id 主键 对象 Wrapper 为 条件构造器 以下为部分接口方法： insert 123456789/** * &lt;p&gt; * 插入一条记录 * &lt;/p&gt; * * @param entity 实体对象 * @return 插入成功记录数 */int insert(T entity); - delete 123456789/** * &lt;p&gt; * 根据 entity 条件，删除记录 * &lt;/p&gt; * * @param wrapper 实体对象封装操作类（可以为 null） * @return 删除成功记录数 */int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper); - updateById 123456789/** * &lt;p&gt; * 根据 ID 修改 * &lt;/p&gt; * * @param entity 实体对象 * @return 修改成功记录数 */int updateById(@Param(Constants.ENTITY) T entity); - selectMaps 123456789/** * &lt;p&gt; * 根据 Wrapper 条件，查询全部记录 * &lt;/p&gt; * * @param queryWrapper 实体对象封装操作类（可以为 null） * @return 字段映射对象 Map 集合 */List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); Service的CRUD接口 说明: 通用 Service CRUD 封装IService接口，进一步封装 CRUD 采用 get 查询单行 remove 删除`list 查询集合page 分页前缀命名方式区分Mapper` 层避免混淆， 泛型 T 为任意实体对象 建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类 对象 Wrapper 为 条件构造器 关于接口内容不再赘述，偶需要看文档。 条件构造器 详见文档 分页插件 1234567&lt;!-- spring xml 方式 --&gt;&lt;plugins&gt; &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;&gt; &lt;property name=&quot;sqlParser&quot; ref=&quot;自定义解析类、可以没有&quot; /&gt; &lt;property name=&quot;dialectClazz&quot; value=&quot;自定义方言类、可以没有&quot; /&gt; &lt;/plugin&gt;&lt;/plugins&gt; 1234567891011121314//Spring boot方式@EnableTransactionManagement@Configuration@MapperScan(&quot;com.baomidou.cloud.service.*.mapper*&quot;)public class MybatisPlusConfig { /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); }} 自定义分页 UserMapper.java方法内容 12345678910111213public interface UserMapper{//可以继承或者不继承BaseMapper /** * &lt;p&gt; * 查询 : 根据state状态查询用户列表，分页显示 * 注意!!: 如果入参是有多个,需要加注解指定参数名才能在xml中取值 * &lt;/p&gt; * * @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位(你可以继承Page实现自己的分页对象) * @param state 状态 * @return 分页对象 */ IPage&lt;User&gt; selectPageVo(Page page, @Param(&quot;state&quot;) Integer state);} UserMapper.xml编写一个list查询 123&lt;select id=&quot;selectPageVo&quot; resultType=&quot;com.baomidou.cloud.entity.UserVo&quot;&gt; SELECT id,name FROM user WHERE state=#{state}&lt;/select&gt; UserServiceImpl调用分页方法 1234567public IPage&lt;User&gt; selectUserPage(Page&lt;User&gt; page, Integer state) { // 不进行 count sql 优化，解决 MP 无法自动优化 SQL 问题，这时候你需要自己查询 count 部分 // page.setOptimizeCountSql(false); // 当 total 为非 0 时(默认为 0),分页插件不会进行 count 查询 // 要点!! 分页返回的对象与传入的对象是同一个 return userMapper.selectPageVo(page, state);} 代码示例如下： 123456789101112131415161718192021222324252627282930313233public class PaginationTest { @Resource private UserMapper mapper; @Test public void tests() { System.out.println(&quot;----- baseMapper 自带分页 ------&quot;); Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); IPage&lt;User&gt; userIPage = mapper.selectPage(page, new QueryWrapper&lt;User&gt;() .eq(&quot;age&quot;, 20).eq(&quot;name&quot;, &quot;Jack&quot;)); assertThat(page).isSameAs(userIPage); System.out.println(&quot;总条数 ------&gt; &quot; + userIPage.getTotal()); System.out.println(&quot;当前页数 ------&gt; &quot; + userIPage.getCurrent()); System.out.println(&quot;当前每页显示数 ------&gt; &quot; + userIPage.getSize()); print(userIPage.getRecords()); System.out.println(&quot;----- baseMapper 自带分页 ------&quot;); System.out.println(&quot;json 正反序列化 begin&quot;); String json = JSON.toJSONString(page); Page&lt;User&gt; page1 = JSON.parseObject(json, TypeBuilder.newInstance(Page.class).addTypeParam(User.class).build()); print(page1.getRecords()); System.out.println(&quot;json 正反序列化 end&quot;); System.out.println(&quot;----- 自定义 XML 分页 ------&quot;); MyPage&lt;User&gt; myPage = new MyPage&lt;User&gt;(1, 5).setSelectInt(20).setSelectStr(&quot;Jack&quot;); ParamSome paramSome = new ParamSome(20, &quot;Jack&quot;); MyPage&lt;User&gt; userMyPage = mapper.mySelectPage(myPage, paramSome); assertThat(myPage).isSameAs(userMyPage); System.out.println(&quot;总条数 ------&gt; &quot; + userMyPage.getTotal()); System.out.println(&quot;当前页数 ------&gt; &quot; + userMyPage.getCurrent()); System.out.println(&quot;当前每页显示数 ------&gt; &quot; + userMyPage.getSize()); print(userMyPage.getRecords()); System.out.println(&quot;----- 自定义 XML 分页 ------&quot;); } ### sql分析打印 ​ 该功能依赖 `p6spy` 组件，完美的输出打印 SQL 及执行时长 `3.1.0` 以上版本 - p6spy 依赖引入 12345&lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; - application.yml配置 12345spring: datasource: dynamic: # 是否开启 SQL日志输出，生产环境建议关闭，有性能损耗 p6spy: true - spy.properties配置 12345678910111213# p6spy配置，文档 https://p6spy.readthedocs.io/en/latest/configandusage.html# 使用日志系统记录 sqlappender=com.p6spy.engine.spy.appender.Slf4JLogger# 自定义日志打印logMessageFormat=cc.mrbird.febs.common.config.P6spySqlFormatConfig# 是否开启慢 SQL记录outagedetection=true# 慢 SQL记录标准 2 秒outagedetectioninterval=2# 开启过滤filter=true# 包含 QRTZ的不打印exclude=QRTZ","link":"/2019/04/26/Mybatis-Plus学习/"}],"tags":[{"name":"tag1","slug":"tag1","link":"/tags/tag1/"},{"name":"tag2","slug":"tag2","link":"/tags/tag2/"},{"name":"tag3","slug":"tag3","link":"/tags/tag3/"}],"categories":[{"name":"默认分类","slug":"默认分类","link":"/categories/默认分类/"}]}